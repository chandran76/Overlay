<element name="u-table" extends="table">
    <style>
        /*td {
            border: 1px #DDD solid;
            padding: 5px;
            cursor: pointer;
        }*/

        :host, .table_area {
            position: relative;
            z-index: 0;
            /*margin-top: 10px;
          padding-top: 20px;*/
        }

        table.fixed_headers {
            display: table;
            table-layout: fixed;
            width: 100%;
            font-family: Arial;
            font-weight: 500;
        }

            /*table.fixed_headers td:first-child{ width: 40%; }*/

            table.fixed_headers tbody {
                display: table;
                /* position: fixed; */
                table-layout: fixed;
                width: 100%;
            }

            table.fixed_headers thead {
                position: fixed;
                /*top: 0;*/
                left: 0;
                right: 0;
                width: 100%;
                height: 35px;
                background: #eee;
                table-layout: fixed;
                display: table;
            }

            table.fixed_headers th {
                background: #eee;
                font-family: "Helvetica Neue",Helvetica,sans-serif,Arial;
                font-size: 100%;
                font-weight: bold;
                font-variant: normal;
            }

            table.fixed_headers td {
                line-height: 2em;
                font-family: "Helvetica Neue",Helvetica,sans-serif,Arial;
                font-size: 90%;
                font-weight: normal;
                font-variant: normal;
            }

            table.fixed_headers tr > td,
            table.fixed_headers th {
                text-align: left;
            }
            
        .selected {
            background-color: brown !important;
            color: #FFF !important;
        }
        
        @media screen and (max-width: 600px) {
              table thead {
                border: none;
                clip: rect(0 0 0 0);
                height: 1px;
                margin: -1px;
                overflow: hidden;
                padding: 0;
                position: absolute;
                width: 1px;
              }
              table tr {
                border-bottom: 3px solid #ddd;
                display: block;
              }
              table td {
                border-bottom: 1px solid #ddd;
                display: block;
                text-align: right;
              }
              table td:before {
                content: attr(data-label);
                float: left;
              }
            }
        
        
    </style>
    <script>
        (function () {
            Bosonic.register({
                get sortable() {
                    return this.hasAttribute('sortable');
                },
                get data() {
                    return this._data;
                },
                set data(data) {
                    var event = this._data ? 'data-change' : 'data-set';
                    this._data = data;
                    this.render(data);
                    this.dispatchEvent(new CustomEvent(event));
                },
                createdCallback: function () {

                },
                render: function (data) {
                    var oldTbody = this.querySelector('tbody');
                    if (oldTbody) {
                        this.removeChild(oldTbody);
                    }
                    var tbody = document.createElement('tbody');
                    this.appendChild(tbody);
                    data.forEach(function (row, index) {
                        this.renderRow(tbody, row, index);
                    }, this);
                },
                renderRow: function (tbody, rowData, index) {
                    var row = tbody.insertRow(index);
                    if (Array.isArray(rowData)) {
                        rowData.forEach(function (cellData, cellIndex) {
                            this.renderCell(row, cellData, cellIndex);
                        }, this);
                    } else {
                        Object.keys(rowData).forEach(function (key, cellIndex) {
                            this.renderCell(row, rowData[key], cellIndex);
                        }, this);
                    }
                },
                renderCell: function (row, cellData, cellIndex) {
                    var cell = row.insertCell(cellIndex),
                        cellContent = document.createTextNode(cellData);
                    cell.appendChild(cellContent);
                    cell.dataset.index = cellIndex;
                }

            });
        })();
    </script>
</element>

<element name="u-table-column-toggle">
    <style>

    </style>
    <script>
        (function () {
            Bosonic.register({
                get table() {
                    return document.getElementById(this.getAttribute('for'));
                },
                get thead() {
                    if (!this.table) return;
                    return this.table.querySelector('thead');
                },
                get hiddenColumns() {
                    //return [].filter.call(this.querySelectorAll('input'), function(input) {
                    //    return !input.checked;
                    //}).map(function(input) {
                    //    return input.dataset;
                    //});

                    var cols = [];
                    $.each(this.thead.columns, function () {
                        if (this.show == "false") {
                            cols.push(this);
                        }
                    });
                    return cols;

                },
                createdCallback: function () {
                    if (!this.table) return;
                    if (this.table.data) {
                        this.render();

                    } else {
                        this.renderListener = this.render.bind(this);
                        this.table.addEventListener('data-set', this.renderListener);

                    }

                },
                render: function () {
                    if (this.renderListener) {
                        this.table.removeEventListener('data-set', this.renderListener);
                    }
                    if (!this.thead || !this.thead.columns) return;
                    this.thead.columns.forEach(function (col) {
                        /*
                        var label = document.createElement('label'),
                            input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = true;
                        input.dataset.key = col.key;
                        input.dataset.index = col.index;
                        label.appendChild(input);
                        label.appendChild(document.createTextNode(col.label));
                        this.appendChild(label);
                        input.addEventListener('change', this.toggle.bind(this), false); */

                        var showcol = (col.show == "true");
                        this.toggleDisplay(col.key, col.index, showcol);

                    }, this);
                    this.table.addEventListener('data-change', this.restoreHiddenColumns.bind(this));
                },
                toggle: function (e) {
                    this.toggleDisplay(e.target.dataset.key, e.target.dataset.index, e.target.checked);
                },
                toggleDisplay: function (key, index, show) {
                    var display = show ? 'table-cell' : 'none';
                    th = this.thead.querySelector('th[data-key="' + key + '"]');
                    th.style.display = display;
                    [].forEach.call(this.table.querySelectorAll('td[data-index="' + index + '"]'), function (cell) {
                        cell.style.display = display;
                    });
                },
                restoreHiddenColumns: function () {
                    this.hiddenColumns.forEach(function (col) {
                        this.toggleDisplay(col.key, col.index, false);
                    }, this);
                }
            });
        })();
    </script>
</element>

<element name="u-thead" extends="thead">
    <style>

    </style>
    <script>
        (function () {
            Bosonic.register({
                get data() {
                    return this.parentNode.data;
                },
                get columns() {
                    return [].map.call(this.querySelectorAll('th'), function (th, index) {
                        return {
                            index: index,
                            key: th.dataset.key,
                            label: th.querySelector('button') ? th.querySelector('button').textContent : null,
                            show: th.dataset.show
                        };
                    });
                },
                createdCallback: function () {
                    if (this.parentNode.sortable) {
                        this.addSortListeners();
                    }

                    //raise the "table-initialize" event for the parent of the "table" element.
                    this.parentNode.parentNode.dispatchEvent(new CustomEvent("table-initialize"));


                },
                sort: function (e) {
                    var old = this.querySelector('th[sort]'),
                        th = e.target.parentNode,
                        key = th.dataset.key,
                        direction = th.getAttribute('sort') === 'desc' ? 'asc' : 'desc';
                    if (old) {
                        old.removeAttribute('sort');
                    }
                    th.setAttribute('sort', direction);
                    var sorted = this.data.sort(function (a, b) {
                        if (a[key] > b[key])
                            return 1;
                        if (a[key] < b[key])
                            return -1;
                        return 0;
                    });
                    if (direction === 'asc') sorted.reverse();
                    this.parentNode.data = sorted;
                },
                addSortListeners: function () {
                    var buttons = this.querySelectorAll('th button');
                    for (var i = 0; i < buttons.length; i++) {
                        buttons[i].addEventListener('click', this.sort.bind(this), false);
                    }
                }
            });
        })();
    </script>
</element>
